<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Clojure.Java-Time</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Clojure.java-time</span> <span class="project-version">1.4.3-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="README.html"><div class="inner"><span>Clojure.Java-Time</span></div></a></li><li class="depth-1 "><a href="CHANGELOG.html"><div class="inner"><span>Changelog</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><a href="java-time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>java-time</span></div></a></li><li class="depth-2 branch"><a href="java-time.api.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>api</span></div></a></li><li class="depth-2"><a href="java-time.repl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>repl</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#clojurejava-time" id="clojurejava-time"></a>Clojure.Java-Time</h1>
<p><a href="https://clojars.org/clojure.java-time"><img src="https://img.shields.io/clojars/v/clojure.java-time.svg" alt="Clojars Project" /></a></p>
<p>A Clojure wrapper for Java 8 Date-Time API.</p>
<blockquote>
<p>Note: This library has no relation to Clojure’s (or Java’s) core team. It’s naming is legacy and preserved for backwards compatibility reasons.</p>
</blockquote>
<h2><a href="#rationale" id="rationale"></a>Rationale</h2>
<p>Main goals:</p>
<ul>
<li>Provide a consistent API for common operations with instants, date-times, zones and periods.</li>
<li>Provide an escape hatch from Java types to clojure data structures.</li>
<li>Avoid reflective calls.</li>
<li>Provide an entry point into Java-Time by freeing the user from importing most of the Java-Time classes.</li>
</ul>
<p>Why use Clojure.Java-Time over <a href="https://github.com/clj-time/clj-time">clj-time</a> or <a href="https://github.com/dm3/clojure.joda-time">Clojure.Joda-Time</a>?</p>
<ul>
<li>You don’t want to have a dependency on the Joda-Time library</li>
<li>You already use Java 8</li>
<li>You prefer as little Java interop code as possible</li>
</ul>
<p>This library employs a structured and comprehensive approach to exposing the Java 8 Date-Time API to the Clojure world. It’s very similar to Clojure.Joda-Time in its design goals and overall feeling, so if you ever used that you will feel at home!</p>
<p>Why use Clojure.Java-Time over <a href="https://github.com/henryw374/cljc.java-time">cljc.java-time</a> with <a href="https://github.com/juxt/tick">tick</a>?</p>
<ul>
<li>You only plan on running on the JVM</li>
<li>You prefer a single <code>require</code> over multiple ones</li>
</ul>
<p>I don’t see any reasons except for aesthetical pleasure and existing knowledge to choose one over the other. However, I have neither used or benchmarked Cljc.Java-Time and Tick so my endorsement is purely on the merits of a broader feature set.</p>
<h2><a href="#documentation" id="documentation"></a>Documentation</h2>
<ul>
<li><a href="https://dm3.github.io/clojure.java-time/">API</a></li>
<li><a href="https://cljdoc.org/d/clojure.java-time/clojure.java-time/CURRENT"><img src="https://cljdoc.org/badge/clojure.java-time/clojure.java-time" alt="cljdoc badge" /></a></li>
</ul>
<h2><a href="#whats-different-in-java-time-api" id="whats-different-in-java-time-api"></a>What’s different in Java Time API?</h2>
<p>If you already used Joda Time before you might think: “What in the world could they do better?”. After all, Joda-Time already provides a pretty comprehensive set of tools for dealing with time-related concepts. Turns out, it’s a tad more complicated than it has to be. Also, a few concepts have faulty designs which lead to hard to fix bugs and misuse. You can see the birds-eye view of changes and some of the rationale on the author’s (Stephen Colebourne) blog:</p>
<ul>
<li><a href="https://blog.joda.org/2009/11/why-jsr-310-isn-joda-time_4941.html">what’s wrong with Joda-Time</a>,</li>
<li><a href="https://blog.joda.org/2014/07/threeten-backport-vs-joda-time.html">when you should use Java-Time</a></li>
<li><a href="https://blog.joda.org/2014/11/converting-from-joda-time-to-javatime.html">what’s different in Java-Time</a>.</li>
</ul>
<p>You can also take a look at a <a href="http://time4j.net/tutorial/appendix.html">comprehensive comparison</a> by the <a href="http://time4j.net/">Time4J</a> authors.</p>
<h2><a href="#usage" id="usage"></a>Usage</h2>
<p>Add the following dependency to your <code>deps.edn</code>:</p>
<pre><code class="language-clj">clojure.java-time/clojure.java-time {:mvn/version "1.4.2"}
</code></pre>
<p>or to your <code>project.clj</code> or <code>build.boot</code>:</p>
<pre><code class="language-clj">[clojure.java-time "1.4.2"]
</code></pre>
<p>The <a href="https://dm3.github.io/clojure.java-time">API</a> of the Clojure.Java-Time consists of one namespace, namely <code>java-time.api</code>.  For the purposes of this guide, we will <code>require</code> the main namespace:</p>
<pre><code class="language-clj">(require '[java-time.api :as jt]
         ;; for REPL experimentation
         'java-time.repl)
</code></pre>
<h3><a href="#concept-run-through" id="concept-run-through"></a>Concept run-through</h3>
<p>The Java Time API may seem daunting. Instead of a single <code>java.util.Date</code> you have a <code>ZonedDateTime</code>, <code>OffsetDateTime</code>, <code>LocalDateTime</code>, <code>Instant</code>, and other types. You would be well served by reading the official documentation for the <a href="https://docs.oracle.com/javase/tutorial/datetime/iso/index.html">Java Time API</a>, but we’ll also do a quick run-through here.</p>
<h4><a href="#local-dates-andor-times" id="local-dates-andor-times"></a>Local Dates and/or Times</h4>
<p><code>LocalDate</code>, <code>LocalTime</code> and <code>LocalDateTime</code> are used to represent a date, time and date-time respectively without an offset or a time zone. The local time entities are used to represent human-based dates/times. They are a good fit for representing the time of various events:</p>
<ul>
<li><code>LocalDate</code> - birthday, holiday
<ul>
<li>see <a href="https://dm3.github.io/clojure.java-time/java-time.api.html#var-local-date"><code>jt/local-date</code></a></li>
</ul>
</li>
<li><code>LocalTime</code> - bus schedule, opening time of a shop
<ul>
<li>see <a href="https://dm3.github.io/clojure.java-time/java-time.api.html#var-local-time"><code>jt/local-time</code></a></li>
</ul>
</li>
<li><code>LocalDateTime</code> - start of a competition
<ul>
<li>see <a href="https://dm3.github.io/clojure.java-time/java-time.api.html#var-local-date-time"><code>jt/local-date-time</code></a></li>
</ul>
</li>
</ul>
<p>Example usage:</p>
<pre><code class="language-clj">(jt/local-date 2015 10)
;=&gt; #&lt;java.time.LocalDate 2015-10-01&gt;

(jt/local-time 10)
;=&gt; #&lt;java.time.LocalTime 10:00&gt;

(jt/local-date-time 2015 10)
;=&gt; #&lt;java.time.LocalDateTime 2015-10-01T00:00&gt;
</code></pre>
<h4><a href="#zoned-dates" id="zoned-dates"></a>Zoned Dates</h4>
<p>There are two types which deal with zones: * <code>OffsetDateTime</code> * see <a href="https://dm3.github.io/clojure.java-time/java-time.api.html#var-offset-date-time"><code>jt/offset-date-time</code></a> * <code>ZonedDateTime</code> * see <a href="https://dm3.github.io/clojure.java-time/java-time.api.html#var-zoned-date-time"><code>jt/zoned-date-time</code></a></p>
<p>They do pretty much what you would expect from their name. You can think of the <code>Offset</code> time as a more concrete version of the <code>Zoned</code> time. For example, the same time zone can have different offsets throughout the year due to DST or governmental regulations.</p>
<pre><code class="language-clj">(jt/offset-time 10)
;=&gt; #&lt;java.time.OffsetTime 10:00+01:00&gt;

(jt/offset-date-time 2015 10)
;=&gt; #&lt;java.time.OffsetDateTime 2015-10-01T10:00+01:00&gt;

(jt/zoned-date-time 2015 10)
;=&gt; #&lt;java.time.ZonedDateTime 2015-10-01T10:00+01:00[Europe/London]&gt;
</code></pre>
<p>Offset/Zone times only take the offset/zone as the last arguments for the maximum arity constructor. You can influence the zone/offset by using the <a href="https://dm3.github.io/clojure.java-time/java-time.api.html#var-with-zone"><code>jt/with-zone</code></a> or <a href="https://dm3.github.io/clojure.java-time/java-time.api.html#var-with-offset"><code>jt/with-offset</code></a> functions, like so:</p>
<pre><code class="language-clj">(jt/with-zone (jt/zoned-date-time 2015 10) "UTC")
;=&gt; #&lt;java.time.ZonedDateTime 2015-10-01T00:00Z[UTC]&gt;

(jt/with-zone-same-instant (jt/zoned-date-time 2015 10) "UTC")
;=&gt; #&lt;java.time.ZonedDateTime 2015-09-30T23:00Z[UTC]&gt;

(jt/with-clock (jt/system-clock "UTC")
  (jt/zoned-date-time 2015 10))
;=&gt; #&lt;java.time.ZonedDateTime 2015-10-01T00:00Z[UTC]&gt;
</code></pre>
<h4><a href="#instant" id="instant"></a>Instant</h4>
<p>An <code>Instant</code> is used to generate a time stamp representing machine time. It doesn’t have an offset or a time zone. You can think of it as of a number of milliseconds since epoch (<code>1970-01-01T00:00:00Z</code>). An instant is directly analogous to <code>java.util.Date</code>:</p>
<pre><code class="language-clj">(jt/instant)
;=&gt; #&lt;java.time.Instant "2015-09-26T05:25:48.667Z"&gt;

(java.util.Date.)
;=&gt; #inst "2015-09-26T05:25:50.118-00:00"
</code></pre>
<p>Every other date entity can be converted to an instant (local ones will require an additional zone information).</p>
<h4><a href="#period-and-duration" id="period-and-duration"></a>Period and Duration</h4>
<p>Java Time Period entities are considerably simpler than the Joda-Time periods. They are fixed containers of years, months and days. You can use them to represent any period of time with a granularity larger or equal to a single day. Duration, on the other hand, represents a standard duration less than or equal to a single standard (24-hour) day.</p>
<h3><a href="#caution" id="caution"></a>Caution</h3>
<p>The current incarnation of the library is relatively slow while calling the 2-3 arity <code>zoned-date-time/offset-time/offset-date-time</code> constructors for the <em>first time</em> in a given Clojure runtime. If you need predictable latency at the time of the first call in your business logic, please warm the constructors you are going to use up by calling them beforehand, e.g.:</p>
<pre><code class="language-clj">(defn warm-up []
  (jt/zoned-date-time 2015 1 1)
  (jt/zoned-date-time 2015 1)
  (jt/zoned-date-time 2015))
</code></pre>
<p>The “constructor” here refers to an arity of a function together with its type signature. For example, a <code>(jt/zoned-date-time 2015)</code> and <code>(jt/zoned-date-time (jt/system-clock))</code> are different constructors.</p>
<h3><a href="#an-appetizer" id="an-appetizer"></a>An appetizer</h3>
<p>First, let’s do a quick run through common use cases.</p>
<p>What is the current date?</p>
<pre><code class="language-clj">(def now (jt/local-date))
;=&gt; #object[java.time.LocalDate "2015-09-27"]
</code></pre>
<p>What’s the next day?</p>
<pre><code class="language-clj">(jt/plus now (jt/days 1))
;=&gt; #object[java.time.LocalDate "2015-09-28"]
</code></pre>
<p>The previous day?</p>
<pre><code class="language-clj">(jt/minus now (jt/days 1))
;=&gt; #object[java.time.LocalDate "2015-09-26"]
</code></pre>
<p>Three days starting at <code>now</code>?</p>
<pre><code class="language-clj">(take 3 (jt/iterate jt/plus now (jt/days 1)))
;=&gt; (#object[java.time.LocalDate "2015-09-27"]
;    #object[java.time.LocalDate "2015-09-28"]
;    #object[java.time.LocalDate "2015-09-29"])
</code></pre>
<p>When is the first Monday in month?</p>
<pre><code class="language-clj">(jt/adjust now :first-in-month :monday)
;=&gt; #object[java.time.LocalDate "2015-09-07"]
</code></pre>
<p>Date with some of its fields truncated:</p>
<pre><code class="language-clj">(jt/truncate-to (jt/local-date-time 2015 9 28 10 15) :days)
;=&gt; #object[java.time.LocalDateTime "2015-09-28T00:00"]
</code></pre>
<p>Date-time adjusted to the given hour:</p>
<pre><code class="language-clj">(jt/adjust (jt/local-date-time 2015 9 28 10 15) (jt/local-time 6))
;=&gt; #object[java.time.LocalDateTime "2015-09-28T06:00"]
</code></pre>
<p>The latest of the given dates?</p>
<pre><code class="language-clj">(jt/max (jt/local-date 2015 9 20) (jt/local-date 2015 9 28) (jt/local-date 2015 9 1))
;=&gt; #object[java.time.LocalDate "2015-09-28"]
</code></pre>
<p>The shortest of the given durations?</p>
<pre><code class="language-clj">(jt/min (jt/duration 10 :seconds) (jt/duration 5 :hours) (jt/duration 3000 :millis))
;=&gt; #object[java.time.Duration "PT3S"]
</code></pre>
<p>Get the year field out of the date:</p>
<pre><code class="language-clj">(jt/as (jt/local-date 2015 9 28) :year)
;=&gt; 2015
</code></pre>
<p>Get multiple fields:</p>
<pre><code class="language-clj">(jt/as (jt/local-date 2015 9 28) :year :month-of-year :day-of-month)
;=&gt; (2015 9 28)
</code></pre>
<p>Get the duration in a different unit:</p>
<pre><code class="language-clj">(jt/plus (jt/hours 3) (jt/minutes 2))
;=&gt; #object[java.time.Duration "PT3H2M"]

(jt/as *1 :minutes)
;=&gt; 182
</code></pre>
<p>Format a date:</p>
<pre><code class="language-clj">(jt/format "MM/dd" (jt/zoned-date-time 2015 9 28))
;=&gt; "09/28"
</code></pre>
<p>Parse a date:</p>
<pre><code class="language-clj">(jt/local-date "MM/yyyy/dd" "09/2015/28")
;=&gt; #object[java.time.LocalDate "2015-09-28"]
</code></pre>
<p>Zoned date-times and offset date-times/times always take the zone/offset as the last argument. Offsets can be specified as float values:</p>
<pre><code class="language-clj">(jt/zone-offset +1.5)
;=&gt; #&lt;java.time.ZoneOffset +01:30&gt;

(jt/zone-offset -1.5)
;=&gt; #&lt;java.time.ZoneOffset -01:30&gt;
</code></pre>
<p>Compare dates:</p>
<pre><code class="language-clj">(jt/before? (jt/year 2020) (jt/year 2021))
;=&gt; true

(jt/after? (jt/year 2021) (jt/year 2021))
;=&gt; false

(let [expiration-date (jt/year 2010)
      purchase-date (jt/year 2010)]
  (jt/not-before? expiration-date purchase-date))
;=&gt; true

(let [start-date (jt/year 2011)
      cutoff-date (jt/year 2010)]
  (jt/not-after? start-date cutoff-date))
;=&gt; false
</code></pre>
<h4><a href="#conversions" id="conversions"></a>Conversions</h4>
<p>Time entities can be converted to other time entities if the target contains less information, e.g. (assuming we’re in UTC time zone):</p>
<pre><code class="language-clj">(jt/zoned-date-time (jt/offset-date-time 2015 9 28 1))
;=&gt; #object[java.time.ZonedDateTime "2015-09-28T01:00Z"]

(jt/instant (jt/offset-date-time 2015 9 28 1))
;=&gt; #object[java.time.Instant "2015-09-28T01:00:00Z"]

(jt/offset-time (jt/offset-date-time 2015 9 28 1))
;=&gt; #object[java.time.OffsetTime "01:00Z"]

(jt/local-date-time (jt/offset-date-time 2015 9 28 1))
;=&gt; #object[java.time.LocalDateTime "2015-09-28T01:00"]

(jt/local-time (jt/offset-time 1))
;=&gt; #object[java.time.LocalTime 0x3a3cd6d5 "01:00"]
</code></pre>
<p>Converting an Instant to ZonedDateTime requires a time zone:</p>
<pre><code class="language-clojure">(jt/zoned-date-time (jt/instant 100) "UTC")
;=&gt; #object[java.time.ZonedDateTime 0x291777c0 "1970-01-01T00:00:00.100Z[UTC]"]
</code></pre>
<h4><a href="#legacy-date-time-types" id="legacy-date-time-types"></a>Legacy Date-Time Types</h4>
<p>Any date which can be converted to an instant, can also be converted to a <code>java.util.Date</code>:</p>
<pre><code class="language-clojure">(jt/java-date (jt/zoned-date-time 2015 9 28))
;=&gt; #inst "2015-09-27T22:00:00.000-00:00"

(jt/java-date 50000)
;=&gt; #inst "1970-01-01T00:00:50.000-00:00"
</code></pre>
<p>An instance of <code>java.util.Date</code> serves the same purpose as the new <code>java.time.Instant</code>. It’s a machine timestamp which isn’t aware of the time zone. Please, do not get confused by the way it is printed by the Clojure printer - the UTC time zone is applied during formatting.</p>
<p>Sometimes you’ll have to work with the legacy <code>java.sql.{Date,Time,Timestamp}</code> types. The correspondence between the legacy types and the new Date-Time entities is as follows:</p>
<ul>
<li><code>java.sql.Date</code>  &lt;-&gt; <code>java.time.LocalDate</code></li>
<li><code>java.sql.Timestamp</code> &lt;-&gt; <code>java.time.LocalDateTime</code></li>
<li><code>java.sql.Time</code> &lt;-&gt; <code>java.time.LocalTime</code></li>
</ul>
<pre><code class="language-clojure">(jt/sql-date 2015 9 28)
;=&gt; #inst "2015-09-27T22:00:00.000-00:00"

(jt/sql-timestamp 2015 9 28 10 20 30 4000000)
;=&gt; #inst "2015-09-28T09:20:30.004-00:00"

(jt/sql-time 10 20 30)
;=&gt; #inst "1970-01-01T09:20:30.000-00:00"
</code></pre>
<p>The results of the above calls get printed as <code>#inst</code> because all of the <code>java.sql.{Date,Time,Timestamp}</code> are subtypes of <code>java.util.Date</code>. Coincidentally, this makes it impossible to plug the <code>java.sql.*</code> types into the Clojure.Java-Time conversion graph.</p>
<p>Conversions to the legacy types also go the other way around:</p>
<pre><code class="language-clojure">(jt/local-date (jt/sql-date 2015 9 28))
;=&gt; #object[java.time.LocalDate "2015-09-28"]

(jt/local-date-time (jt/sql-timestamp 2015 9 28 10 20 30 4000000))
;=&gt; #object[java.time.LocalDateTime "2015-09-28T10:20:30.004"]

(jt/local-time (jt/sql-time 10 20 30))
;=&gt; #object[java.time.LocalTime "10:20:30"]
</code></pre>
<h4><a href="#three-ten-extra" id="three-ten-extra"></a>Three-Ten Extra</h4>
<p>If you add an optional <code>[org.threeten/threeten-extra "1.2"]</code> dependency to the project, you will get an <code>Interval</code>, <code>AmPm</code>, <code>DayOfMonth</code>, <code>DayOfYear</code>, <code>Quarter</code> and <code>YearQuarter</code> data types as well as a couple more adjusters.</p>
<p>An interval can be constructed from two entities that can be converted to instants:</p>
<pre><code class="language-clojure">(jt/interval (jt/offset-date-time 2015 1 1) (jt/zoned-date-time 2016 1 1))
;=&gt; #&lt;org.threeten.extra.Interval 2015-01-01T00:00:00Z/2016-01-01T00:00:00Z&gt;

(jt/move-start-by *1 (jt/duration 5 :days))
;=&gt; #&lt;org.threeten.extra.Interval 2015-01-06T00:00:00Z/2016-01-01T00:00:00Z&gt;

(jt/move-end-by *1 (jt/duration 5 :days))
;=&gt; #&lt;org.threeten.extra.Interval 2015-01-06T00:00:00Z/2016-01-06T00:00:00Z&gt;

(jt/contains? *1 (jt/offset-date-time 2015 1 1))
;=&gt; false
</code></pre>
<h4><a href="#joda-time" id="joda-time"></a>Joda-Time</h4>
<p>Bonus! If you have Joda Time on the classpath (either directly, or via <code>clj-time</code>), you can seamlessly convert from Joda Time to Java Time types:</p>
<pre><code class="language-clojure">(java-time.repl/show-path org.joda.time.DateTime java.time.OffsetTime)
;=&gt; {:cost 2.0,
;    :path [[#&lt;java_time.graph.Types@15e43c24 [org.joda.time.DateTime]&gt;
;            #&lt;java_time.graph.Types@78a2235c [java.time.Instant java.time.ZoneId]&gt;]
;           [#&lt;java_time.graph.Types@6d8ded1a [java.time.Instant java.time.ZoneId]&gt;
;            #&lt;java_time.graph.Types@5360f6ae [java.time.OffsetTime]&gt;]]}

(jt/offset-time (org.joda.time.DateTime/now))
;=&gt; #&lt;java.time.OffsetTime 22:00:00.000000000-00:00&gt;
</code></pre>
<p>Clojure 1.9 added an <a href="https://clojuredocs.org/clojure.core/inst_q">Inst</a> protocol which is implemented for <code>java.util.Date</code> and <code>java.time.Instant</code> by default. If you’re stuck on Joda-Time, you can extend the <code>org.joda.time.ReadableInstant</code>, which includes both <code>Instant</code> and <code>DateTime</code> using the following:</p>
<pre><code class="language-clojure">(jt/when-joda-time-loaded
  (extend-type org.joda.time.ReadableInstant
    Inst (inst-ms* [inst] (.getMillis inst))))
</code></pre>
<p>This snippet isn’t included in the Clojure.Java-Time code by default as both the <code>Inst</code> protocol and the Joda-Time types are external to the library.</p>
<h4><a href="#clocks" id="clocks"></a>Clocks</h4>
<p>Java Time introduced a concept of <code>Clock</code> - a time entity which can seed the dates, times and zones. However, there’s no built-in facility which would allow you to influence the date-times created using default constructors à la Joda’s <code>DateTimeUtils/setCurrentMillisSystem</code>. Clojure.Java-Time tries to fix that with the <code>with-clock</code> macro and the corresponding <code>with-clock-fn</code> function:</p>
<pre><code class="language-clojure">(jt/zone-id)
;=&gt; #&lt;java.time.ZoneRegion Europe/London&gt;

(jt/with-clock (jt/system-clock "UTC")
  (jt/zone-id))
;=&gt; #&lt;java.time.ZoneRegion UTC&gt;
</code></pre>
<p>In addition to the built-in <code>java.time</code> clocks, we provide a Mock clock which can be very handy in testing:</p>
<pre><code class="language-clojure">(def clock (jt/mock-clock 0 "UTC"))
;=&gt; #'user/clock

(jt/with-clock clock
  (jt/instant))
;=&gt; #object[java.time.Instant "1970-01-01T00:00:00Z"]

(jt/advance-clock! clock (jt/plus (jt/hours 5) (jt/minutes 20)))
;=&gt; nil

(jt/with-clock clock
  (jt/instant))
;=&gt; #object[java.time.Instant "1970-01-01T05:20:00Z"]

(jt/set-clock! clock 0)
;=&gt; nil

(jt/with-clock clock
  (jt/instant))
;=&gt; #object[java.time.Instant "1970-01-01T00:00:00Z"]
</code></pre>
<p>Clock overrides works for all of the date-time types.</p>
<h4><a href="#fields-units-and-properties" id="fields-units-and-properties"></a>Fields, Units and Properties</h4>
<p>Date-Time entities are composed of date fields, while Duration entities are composed of time units. You can see all of the predefined fields and units via the <code>java-time.repl</code> ns:</p>
<pre><code class="language-clojure">(java-time.repl/show-fields)
;=&gt; (:aligned-day-of-week-in-month
;    :aligned-day-of-week-in-year
;    :aligned-week-of-month
;    :aligned-week-of-year
;    :am-pm-of-day
;    :clock-hour-of-am-pm
;    ...)
</code></pre>
<pre><code class="language-clojure">(java-time.repl/show-units)
;=&gt; (:centuries
;    :days
;    :decades
;    :eras
;    :forever
;    :half-days
;    ...)
</code></pre>
<p>You can obtain any field/unit like this:</p>
<pre><code class="language-clojure">(jt/field :year)
;=&gt; #object[java.time.temporal.ChronoField "Year"]

(jt/unit :days)
;=&gt; #object[java.time.temporal.ChronoUnit "Days"]

(jt/field (jt/local-date 2015) :year)
;=&gt; #object[java.time.temporal.ChronoField "Year"]
</code></pre>
<p>You can obtain all of the fields/units of the temporal entity:</p>
<pre><code class="language-clojure">(jt/fields (jt/local-date))
;=&gt; {:proleptic-month #object[java.time.temporal.ChronoField ...}

(jt/units (jt/duration))
;=&gt; {:seconds #object[java.time.temporal.ChronoUnit "Seconds"],
;    :nanos #object[java.time.temporal.ChronoUnit "Nanos"]}
</code></pre>
<p>By themselves the fields and units aren’t very interesting. You can get the range of valid values for a field and a duration between two dates, but that’s about it:</p>
<pre><code class="language-clojure">(jt/range (jt/field :year))
;=&gt; #object[java.time.temporal.ValueRange "-999999999 - 999999999"]

(jt/range (jt/field :day-of-month))
;=&gt; #object[java.time.temporal.ValueRange "1 - 28/31"]

(jt/time-between (jt/local-date 2015 9) (jt/local-date 2015 9 28) :days)
;=&gt; 27
</code></pre>
<p>Fields and units become interesting in conjunction with properties. Java-Time doesn’t support the concept of properties which is present in Joda-Time. There are reasons for that which I feel are only valid in a statically-typed API like Java’s. In Clojure, properties allow expressing time entity modifications and queries uniformly across all of the entity types.</p>
<pre><code class="language-clojure">(def prop (jt/property (jt/local-date 2015 2 28) :day-of-month))
;=&gt; #java_time.temporal.TemporalFieldProperty{...}

(jt/value prop)
;=&gt; 28

(jt/with-min-value prop)
;=&gt; #object[java.time.LocalDate "2015-02-01"]

(jt/with-value prop 20)
;=&gt; #object[java.time.LocalDate "2015-02-20"]

(jt/with-max-value prop)
;=&gt; #object[java.time.LocalDate "2015-02-28"]

(jt/properties (jt/local-date 2015 9 28))
;=&gt; {:proleptic-month #java_time.temporal.TemporalFieldProperty{...}, ...}
</code></pre>
<h2><a href="#implementation-details" id="implementation-details"></a>Implementation Details</h2>
<p>Most of the temporal entity constructors with arities 1 to 3 use the conversion graph underneath. This provides for a very flexible way of defining the conversions while avoiding huge conditional statements and multiple definitions of the identical conversion logic. However, the flexibility comes with a cost:</p>
<ol>
<li>The first call to a constructor will take a <em>long</em> time as it will try to find a path in the conversion graph. Subsequent calls will reuse the path.</li>
<li>It’s not trivial to evaluate the impact of adding and removing conversions both on the performance and the conversion path chosen for certain arguments.</li>
<li>You might get nonsensical results for some of the paths in the graph that you might expect would make sense.</li>
</ol>
<p>Hopefully, the performance issue will be resolved in the future…</p>
<p>You can play with the conversion graph using the following helpers:</p>
<pre><code class="language-clojure">(java-time.repl/show-path org.joda.time.DateTime java.time.OffsetTime)
;=&gt; {:cost 2.0,
;    :path [[#&lt;java_time.graph.Types@15e43c24 [org.joda.time.DateTime]&gt;
;            #&lt;java_time.graph.Types@78a2235c [java.time.Instant java.time.ZoneId]&gt;]
;           [#&lt;java_time.graph.Types@6d8ded1a [java.time.Instant java.time.ZoneId]&gt;
;            #&lt;java_time.graph.Types@5360f6ae [java.time.OffsetTime]&gt;]]}

(java-time.repl/show-graph)
;=&gt; {1
;    {org.threeten.extra.DayOfYear
;     [[#object[java_time.graph.Types "[java.lang.Number]"]
;       #object[java_time.graph.Conversion "Cost:1.0"]]],
;     java.lang.Number
;     [[#object[java_time.graph.Types "[java.time.Instant]"]
;       #object[java_time.graph.Conversion "Cost:1.0"]]
;     ...}}
</code></pre>
</div></div></div></body></html>